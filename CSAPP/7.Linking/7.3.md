# 7.3

## A

`p.o -> libx.a`:

```shell
gcc p.o libx.a
```

## B

`p.o -> libx.a -> liby.a`: 

```shell
gcc p.o libx.a liby.a
```

## C

`p.o -> libx.a -> liby.a` AND `liby.a -> libx.a -> p.o`:

```shell
gcc p.o libx.a liby.a libx.a
```

I wrote a demo in `Problem_7.3/`. Feel free to modify the `$(LIB)` in `Makefile` to trigger linking errors.

- Dependency chain: `p.c -> x1.c -> y1.c -> y2.c -> x2.c -> p.c`
- `libx.a` consists of `x1.c` and `x2.c`.
- `liby.a` consists of `y1.c` and `y2.c`.

- When the first time `libx.a` is linked, it only sees `p.o` is calling `x_for_p` and links module `x1`. The linker discard module `x2`.
- When `y1.y_for_x -> y2.another_y -> x2.x_for_y` needs to be linked, it cannot resolve the symbol `x_for_y` because `x2` is discarded
- `libx.a` needs to be linked again. It needs `p_for_x`, but this symbol is already linked when `p.o` is resolved.
